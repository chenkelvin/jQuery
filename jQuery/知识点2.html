<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>知识点：面向对象与闭包</title>
	<script>
	/*
		本节大纲：
			1.面向对象
			2.匿名函数
			3.闭包
		---------------------------------------------------
		1.面向对象
			如何创建对象:
			1）直接量
				var student = {id:10,name:'小明',age:18}
			2）new关键字
				var student = new Object()
				student.id = 10;
				student.name = '王铁锤';
				student.age = 18;
				缺点：使用同一个接口创建很多对象，会产生大量的重复代码
			3）封装工厂函数
				为了减少重复代码，对上述代码进行封装
			4）自定义构造函数
				function Student(name, age){
					this.name = name;
					this.age = age;
					this.sayName = function(){alert(this.name);};
				}
				var s1 = new Student("王铁锤", 18);
				这种方式调用构造函数实际上会经历以下4个步骤：
					1> 创建一个新对象；
					2> 将构造函数的作用域赋给新对象（把this绑定到实例对象）；
					3> 执行构造函数中的代码（为这个新对象添加属性）；
					4> 返回新对象。

				**this作为JS的关键字，有特殊的含义，代表了当前对象，而当前对象是谁，由函数执行时所处的环境来决定
					1>用new关键字执行：this指向生成的实例对象
					2>普通函数执行：this指向调用函数的对象

				构造函数与普通函数的唯一区别（调用方式不同）：
					1>任何函数，只要通过new操作符来调用，它就可以作为构造函数；
					2>而任何构造函数，如果不通过new 操作符来调用，那它跟普通函数无区别。
				约定：构造函数首字母大写
				缺点： 构造函数方法很好用，但是存在一个浪费内存的问题。这样既不环保，也缺乏效率。
			5）原型对象：prototype
				1> 我们创建的每个函数都有一个prototype属性，这个属性值就是原型对象
				2> 原型对象默认包含一个constructor属性，指向构造函数
				3> 任何写在原型对象中的属性和方法都可以让所有对象实例共享

			实例：
				1）用new关键字生成的实例，会复制构造函数内所有的属性和方法
				2）当调用构造函数创建一个新实例后，该实例的内部将包含一个内部属性[[Prototype]]，指向构造函数的原型对象。这个内部属性无法直接访问，在FF,Chrome等浏览器可以通过__proto__得到；或者通过ES5方式Object.getPrototypeOf(实例)去获取


				3）构造函数、原型对象和实例的关系：
					1>每个构造函数都有一个原型对象（prototype），
					2>原型对象都包含一个指向构造函数的指针（constructor），
					3>而实例都包含一个指向原型对象的内部指针（[[prototype]]）

				4）判断原型和实例的关系（返回布尔值）
					constructor: 得到构造函数的引用，一般用于判断该实例是否由某一构造函数生成
						实例.constructor == Student //true
					instanceof: 检测某个对象是不是某一构造函数的实例，适用于原型链中的所有实例
						实例 instanceof Student //true
						实例 instanceof Object //true
					isPrototypeOf: 判断当前对象是否为实例的原型
						原型对象.isPrototypeOf(实例) //true

		2.匿名函数
			1）匿名函数与具名函数的区别

			2）匿名函数自动执行
				(function(){
					alert("abc");
				})();
				使用()将匿名函数包围，然后再调用,这叫做匿名函数的自运行
		3.闭包
			1）正常情况下外部无法访问函数内部的内容
			2）利用函数内部可访问外部变量的特性, 在函数内部返回一个函数
			3）垃圾回收机制
			js内部定时扫描内存,并清理无引用对象;

			结论：一个可以从外部访问内部变量的函数称之为闭包
			闭包，可以访问函数内部的局部变量，并让其长期驻留内存

			[案例]点击按钮打印当前索引值
			[案例]tab标签切换

			PS：由于闭包会携带包含它的作用域，因此会比其他函数占用更多内存，过度使用闭包可能会造成性能问题。

		作业：
			1、封装extend方法,用以复制对象(浅拷贝与深拷贝)
			2、给所有的字符串添加一个获取ascii码的方法和一个反编译的方法
			3、弹幕
		*/
		// extend({name:'xxx',age:18,hobby:['打篮球','羽毛球','乒乓球']},{age:30,gender:'男',hobby:['写作业','打游戏','女']});
	// {name:'xxx',age:30,gender:'男',hobby:['打篮球','羽毛球','乒乓球','写作业','打游戏','女']}
	</script>
</head>
<body>
	
</body>
</html>